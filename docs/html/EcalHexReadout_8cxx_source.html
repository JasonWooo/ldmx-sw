<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LDMX Software: DetDescr/src/EcalHexReadout.cxx Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LDMX Software</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">DetDescr/src/EcalHexReadout.cxx</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include &quot;<a class="code" href="EcalHexReadout_8h.html" title="Class that translates raw positions of ECal module hits into cells in a hexagonal readout...">DetDescr/EcalHexReadout.h</a>&quot;</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#include &quot;TList.h&quot;</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &quot;TGeoPolygon.h&quot;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &quot;TGraph.h&quot;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &quot;TMultiGraph.h&quot;</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="keyword">namespace </span>ldmx {
<a name="l00012"></a>00012 
<a name="l00013"></a><a class="code" href="classldmx_1_1EcalHexReadout.html#aba849ea2120d49e9fd79ef1307ec156b">00013</a>     <a class="code" href="classldmx_1_1EcalHexReadout.html#aba849ea2120d49e9fd79ef1307ec156b">EcalHexReadout::EcalHexReadout</a>(<span class="keywordtype">double</span> moduleMinR, <span class="keywordtype">double</span> gap, <span class="keywordtype">unsigned</span> nCellsWide){
<a name="l00014"></a>00014 
<a name="l00015"></a>00015         <span class="comment">// ORIENTATION ASSUMPTIONS:</span>
<a name="l00016"></a>00016         <span class="comment">//   modules are oriented flat side down. cells are oriented corner side down.</span>
<a name="l00017"></a>00017         <span class="comment">//   module corners are one cell -- the &#39;single mousebite&#39; cell layout.</span>
<a name="l00018"></a>00018         <span class="comment">//   cells along center horizontal line form a neat row and share vertical edges.</span>
<a name="l00019"></a>00019         <span class="comment">// SOME GEOMETRY:</span>
<a name="l00020"></a>00020         <span class="comment">//   hexagons have two radii:</span>
<a name="l00021"></a>00021         <span class="comment">//     r (half of flat-to-flat width) and R (half of corner-to-corner width).</span>
<a name="l00022"></a>00022         <span class="comment">//     r = (sqrt(3)/2)R and s = R, where s is the length of an edge.</span>
<a name="l00023"></a>00023         <span class="comment">//   for seven ecal modules oriented flat-side-down, maximum x and y extents are:</span>
<a name="l00024"></a>00024         <span class="comment">//     deltaY = 6r&#39; + 2g = 3sqrt(3)R&#39; + 2g</span>
<a name="l00025"></a>00025         <span class="comment">//     deltaX = 4R&#39; + s&#39; + 2g/cos(30 deg) = 5R&#39; + 4g/sqrt(3)</span>
<a name="l00026"></a>00026         <span class="comment">//     where g is uniform gap width between modules, and primed variables correspond to modules.</span>
<a name="l00027"></a>00027         <span class="comment">// THIS GRID:</span>
<a name="l00028"></a>00028         <span class="comment">//   column-to-column distance in a grid such as ours is 2r = sqrt(3)R.</span>
<a name="l00029"></a>00029         <span class="comment">//   row-to-row distance is 1.5R (easy to observe that twice that distance = 3R)</span>
<a name="l00030"></a>00030         <span class="comment">//   a cell will be centered at (0,0).</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032         assert(nCellsWide % 2 == 1); <span class="comment">// calculations rely on centering a cell at (0,0)</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034         <span class="comment">// calculate module radius reduction due to module edges cutting off outer cell corners.</span>
<a name="l00035"></a>00035         <span class="comment">//   r = cell center-to-flat (i.e. minimum) radius</span>
<a name="l00036"></a>00036         <span class="comment">//   R = cell center-to-corner (i.e. maximum) radius</span>
<a name="l00037"></a>00037         <span class="comment">//   s = R = cell edge length</span>
<a name="l00038"></a>00038         <span class="comment">//   nCellsWide = count of cells along horizontal center row</span>
<a name="l00039"></a>00039         <span class="comment">//   moduleMaxR = module center-to-corner radius</span>
<a name="l00040"></a>00040         <span class="comment">//   moduleMinR = module center-to-flat radius</span>
<a name="l00041"></a>00041         <span class="comment">//   lengthWide = total length of CELLS along horizontal center row</span>
<a name="l00042"></a>00042         <span class="comment">//   x = distance from module&#39;s corner to outside flat edge of cell it resides in</span>
<a name="l00043"></a>00043         <span class="comment">//   THEN</span>
<a name="l00044"></a>00044         <span class="comment">//   nCellsWide*(2*r) = lengthWide = 2*moduleMaxR + 2*x</span>
<a name="l00045"></a>00045         <span class="comment">//   AND tan(30 deg) = x/(s/2), or x = s/(2*sqrt(3)),</span>
<a name="l00046"></a>00046         <span class="comment">//   SO nCellsWide*r = moduleMaxR + R/(2*sqrt(3)) = moduleMaxR + r/3</span>
<a name="l00047"></a>00047         <span class="comment">//   SO r = moduleMaxR/(nCellsWide - 1/3) = (1/2)*(2*moduleMaxR/(nCellsWide - 1/3))</span>
<a name="l00048"></a>00048         <span class="comment">//   AND lengthWide = nCellsWide*2*r = nCellsWide*(2*moduleMaxR/(nCellsWide - 1/3))</span>
<a name="l00049"></a>00049         <span class="comment">//</span>
<a name="l00050"></a>00050         <span class="comment">//   Test: moduleMaxR = 1., nCellsWide = 1</span>
<a name="l00051"></a>00051         <span class="comment">//         r = 1/(1-1/3) = 1.5, lengthWide = 3</span>
<a name="l00052"></a>00052         <span class="comment">//         Checked with a ruler - correct.</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054         gap_        = gap;
<a name="l00055"></a>00055         moduler_    = moduleMinR;
<a name="l00056"></a>00056         moduleR_    = moduler_*(2./sqrt(3.));
<a name="l00057"></a>00057         nCellsWide_ = nCellsWide;
<a name="l00058"></a>00058         cellr_      = moduleR_/(nCellsWide - 1./3.);
<a name="l00059"></a>00059         cellR_      = (2./sqrt(3.))*cellr_;
<a name="l00060"></a>00060         lengthWide_ = nCellsWide*2.*cellr_;
<a name="l00061"></a>00061         <span class="keywordflow">if</span>(verbose_&gt;0){
<a name="l00062"></a>00062             std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;[EcalHexReadout] Verbosity set in header to &quot;</span> &lt;&lt; verbose_ &lt;&lt; std::endl;
<a name="l00063"></a>00063             std::cout &lt;&lt; TString::Format(<span class="stringliteral">&quot;Building module map with gap %.2f, lengthWide %.2f, nCellsWide %d &quot;</span>,gap_,lengthWide_,nCellsWide_) &lt;&lt; std::endl;
<a name="l00064"></a>00064             std::cout &lt;&lt; TString::Format(<span class="stringliteral">&quot;  min/max radii of cell %.2f %.2f and module %.2f %.2f&quot;</span>,cellr_,cellR_,moduler_,moduleR_) &lt;&lt; std::endl;
<a name="l00065"></a>00065         }
<a name="l00066"></a>00066 
<a name="l00067"></a>00067         <a class="code" href="classldmx_1_1EcalHexReadout.html#affdf0e47ee886fb03aac6fbd6af6b641">ecalMap_</a> = <span class="keyword">new</span> TH2Poly();
<a name="l00068"></a>00068         gridMap_ = <span class="keyword">new</span> TH2Poly();
<a name="l00069"></a>00069         <a class="code" href="classldmx_1_1EcalHexReadout.html#a05e3dc7a3e36411474327cc877cb0079">buildModuleMap</a>();
<a name="l00070"></a>00070         <a class="code" href="classldmx_1_1EcalHexReadout.html#ab42dd6bfd06539ace4bedfa6e5c6bfad">buildCellMap</a>();
<a name="l00071"></a>00071         <a class="code" href="classldmx_1_1EcalHexReadout.html#a201ec824d6806ff70bdb716cc42cc70e">buildCellModuleMap</a>();
<a name="l00072"></a>00072         <a class="code" href="classldmx_1_1EcalHexReadout.html#ac4aeb2b9831ad98110e4984f2c6f766b">buildNeighborMaps</a>();
<a name="l00073"></a>00073         <span class="keywordflow">if</span>(verbose_&gt;0){ std::cout &lt;&lt; std::endl; }
<a name="l00074"></a>00074     }
<a name="l00075"></a>00075 
<a name="l00076"></a><a class="code" href="classldmx_1_1EcalHexReadout.html#a05e3dc7a3e36411474327cc877cb0079">00076</a>     <span class="keywordtype">void</span> <a class="code" href="classldmx_1_1EcalHexReadout.html#a05e3dc7a3e36411474327cc877cb0079">EcalHexReadout::buildModuleMap</a>(){
<a name="l00077"></a>00077         <span class="keywordflow">if</span>(verbose_&gt;0) std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;[buildModuleMap] Building module position map for module min r of &quot;</span> &lt;&lt; moduler_ &lt;&lt; std::endl;
<a name="l00078"></a>00078         <span class="comment">// module IDs are 0 for ecal center, 1 at 12 o&#39;clock, and clockwise till 6 at 11 o&#39;clock.</span>
<a name="l00079"></a>00079         <span class="keywordtype">double</span> C_PI = 3.14159265358979323846; <span class="comment">// or TMath::Pi(), #define, atan(), ...</span>
<a name="l00080"></a>00080         modulePositionMap_[0] = std::pair&lt;double,double&gt;(0.,0.);
<a name="l00081"></a>00081         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span> = 1 ; <span class="keywordtype">id</span> &lt; 7 ; <span class="keywordtype">id</span>++){
<a name="l00082"></a>00082             <span class="keywordtype">double</span> x = (2.*moduler_+gap_)*sin( (<span class="keywordtype">id</span>-1)*(C_PI/3.) );
<a name="l00083"></a>00083             <span class="keywordtype">double</span> y = (2.*moduler_+gap_)*cos( (<span class="keywordtype">id</span>-1)*(C_PI/3.) );
<a name="l00084"></a>00084             modulePositionMap_[id] = std::pair&lt;double,double&gt;(x,y);
<a name="l00085"></a>00085             <span class="keywordflow">if</span>(verbose_&gt;2) std::cout &lt;&lt; TString::Format(<span class="stringliteral">&quot;   id %d is at (%.2f, %.2f)&quot;</span>,<span class="keywordtype">id</span>,x,y) &lt;&lt; std::endl;
<a name="l00086"></a>00086         }
<a name="l00087"></a>00087         <span class="keywordflow">if</span>(verbose_&gt;0) std::cout &lt;&lt; std::endl;
<a name="l00088"></a>00088     }
<a name="l00089"></a>00089 
<a name="l00090"></a><a class="code" href="classldmx_1_1EcalHexReadout.html#a201ec824d6806ff70bdb716cc42cc70e">00090</a>     <span class="keywordtype">void</span> <a class="code" href="classldmx_1_1EcalHexReadout.html#a201ec824d6806ff70bdb716cc42cc70e">EcalHexReadout::buildCellModuleMap</a>(){
<a name="l00091"></a>00091         <span class="keywordflow">if</span>(verbose_&gt;0) std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;[buildCellModuleMap] Building cellModule position map&quot;</span> &lt;&lt; std::endl;
<a name="l00092"></a>00092         <span class="keywordflow">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span>&amp; module : modulePositionMap_) {
<a name="l00093"></a>00093             <span class="keywordtype">int</span> moduleID = module.first;
<a name="l00094"></a>00094             <span class="keywordtype">double</span> moduleX = module.second.first;
<a name="l00095"></a>00095             <span class="keywordtype">double</span> moduleY = module.second.second;
<a name="l00096"></a>00096             <span class="keywordflow">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span>&amp; cell : cellPositionMap_) {
<a name="l00097"></a>00097                 <span class="keywordtype">int</span> cellID = cell.first;
<a name="l00098"></a>00098                 <span class="keywordtype">double</span> cellX = cell.second.first;
<a name="l00099"></a>00099                 <span class="keywordtype">double</span> cellY = cell.second.second;
<a name="l00100"></a>00100                 <span class="keywordtype">double</span> x = cellX+moduleX;
<a name="l00101"></a>00101                 <span class="keywordtype">double</span> y = cellY+moduleY;
<a name="l00102"></a>00102                 <span class="keywordtype">int</span> cellModuleID = <a class="code" href="classldmx_1_1EcalHexReadout.html#a9c315f04f880d8c151c2963d05b3cf6b">combineID</a>(cellID,moduleID);
<a name="l00103"></a>00103                 cellModulePositionMap_[cellModuleID] = std::pair&lt;double,double&gt;(x,y);
<a name="l00104"></a>00104             }
<a name="l00105"></a>00105         }
<a name="l00106"></a>00106         <span class="keywordflow">if</span>(verbose_&gt;0) std::cout &lt;&lt; <span class="stringliteral">&quot;  contained &quot;</span> &lt;&lt; cellModulePositionMap_.size() &lt;&lt; <span class="stringliteral">&quot; entries. &quot;</span> &lt;&lt; std::endl;
<a name="l00107"></a>00107     }
<a name="l00108"></a>00108 
<a name="l00109"></a><a class="code" href="classldmx_1_1EcalHexReadout.html#ab42dd6bfd06539ace4bedfa6e5c6bfad">00109</a>     <span class="keywordtype">void</span> <a class="code" href="classldmx_1_1EcalHexReadout.html#ab42dd6bfd06539ace4bedfa6e5c6bfad">EcalHexReadout::buildCellMap</a>(){
<a name="l00116"></a>00116         <span class="keywordflow">if</span>(<a class="code" href="classldmx_1_1EcalHexReadout.html#affdf0e47ee886fb03aac6fbd6af6b641">ecalMap_</a>) <a class="code" href="classldmx_1_1EcalHexReadout.html#affdf0e47ee886fb03aac6fbd6af6b641">ecalMap_</a>-&gt;Clear();
<a name="l00117"></a>00117         <span class="keywordflow">if</span>(gridMap_) gridMap_-&gt;Clear();
<a name="l00118"></a>00118 
<a name="l00119"></a>00119         <span class="comment">// make hexagonal grid [boundary is rectangle] larger than the module</span>
<a name="l00120"></a>00120         <span class="keywordtype">unsigned</span> gridCellsWide = nCellsWide_+2;
<a name="l00121"></a>00121         <span class="keywordflow">if</span>( (nCellsWide_-1) % 4 == 0) gridCellsWide += 2; <span class="comment">// parity case</span>
<a name="l00122"></a>00122         columnDistance_ = 2*cellr_;
<a name="l00123"></a>00123         rowDistance_ = 1.5*cellR_;
<a name="l00124"></a>00124         <span class="keywordtype">double</span> gridWidth = (gridCellsWide)*columnDistance_;
<a name="l00125"></a>00125         <span class="keywordtype">double</span> gridHeight = (gridCellsWide-1)*rowDistance_ + 2*cellR_;
<a name="l00126"></a>00126         gridMap_-&gt;Honeycomb( -gridWidth/2, -gridHeight/2, cellR_, gridCellsWide, gridCellsWide);
<a name="l00127"></a>00127 
<a name="l00128"></a>00128         <span class="keywordflow">if</span>(verbose_&gt;0){
<a name="l00129"></a>00129             std::cout &lt;&lt; std::endl;
<a name="l00130"></a>00130             std::cout &lt;&lt; TString::Format(<span class="stringliteral">&quot;[buildCellMap] cell rmin/max %.2f %.2f yield columnDistance_ %.2f, rowDistance_ %.2f&quot;</span>,
<a name="l00131"></a>00131                                                                       cellr_, cellR_, columnDistance_, rowDistance_) &lt;&lt; std::endl;
<a name="l00132"></a>00132             std::cout &lt;&lt; TString::Format(<span class="stringliteral">&quot;[buildCellMap] gridCellsWide %d, gridWidth %.2f, gridHeight %.2f&quot;</span>,
<a name="l00133"></a>00133                                                                       gridCellsWide, gridWidth, gridHeight) &lt;&lt; std::endl;
<a name="l00134"></a>00134         }
<a name="l00135"></a>00135 
<a name="l00136"></a>00136         <span class="comment">// copy cells lying within module boundaries to a module grid</span>
<a name="l00137"></a>00137         std::vector&lt;int&gt; cellIdCopied(gridMap_-&gt;GetNumberOfBins());
<a name="l00138"></a>00138         TListIter next(gridMap_-&gt;GetBins()); <span class="comment">// a TH2Poly is a TList of TH2PolyBin</span>
<a name="l00139"></a>00139         TH2PolyBin *polyBin = 0;
<a name="l00140"></a>00140         TGraph * poly = 0; <span class="comment">// a polygon returned by TH2Poly is a TGraph</span>
<a name="l00141"></a>00141         <span class="keywordtype">int</span> ecalMapID = 0; <span class="comment">// ecalMap cell IDs go from 0 to N-1, not equal to original grid cell ID.</span>
<a name="l00142"></a>00142         <span class="keywordflow">while</span>( (polyBin = (TH2PolyBin*)next()) ){
<a name="l00143"></a>00143             <span class="keywordtype">int</span> <span class="keywordtype">id</span> = polyBin-&gt;GetBinNumber();
<a name="l00144"></a>00144             <span class="keywordtype">double</span> x = (polyBin-&gt;GetXMax() + polyBin-&gt;GetXMin()) / 2.;
<a name="l00145"></a>00145             <span class="keywordtype">double</span> y = (polyBin-&gt;GetYMax() + polyBin-&gt;GetYMin()) / 2.;
<a name="l00146"></a>00146             poly = (TGraph*)polyBin-&gt;GetPolygon();
<a name="l00147"></a>00147 
<a name="l00148"></a>00148             <span class="keywordflow">if</span>(verbose_&gt;1) std::cout &lt;&lt; TString::Format(<span class="stringliteral">&quot;[buildCellMap] Grid cell center ID=%d, XY=(%.2f,%.2f)&quot;</span>,<span class="keywordtype">id</span>,x,y) &lt;&lt; std::endl;
<a name="l00149"></a>00149             <span class="keywordflow">if</span>(verbose_&gt;2){
<a name="l00150"></a>00150               std::cout &lt;&lt; <span class="stringliteral">&quot;[buildCellMap] Cell vertices&quot;</span> &lt;&lt; std::endl;
<a name="l00151"></a>00151               <span class="keywordtype">double</span> tmpx=0, tmpy=0;
<a name="l00152"></a>00152               <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0 ; i &lt; poly-&gt;GetN() ; i++){
<a name="l00153"></a>00153                   std::cout &lt;&lt; <span class="stringliteral">&quot;     vtx # &quot;</span> &lt;&lt; poly-&gt;GetPoint(i,tmpx,tmpy) &lt;&lt; std::endl;
<a name="l00154"></a>00154                   std::cout &lt;&lt; <span class="stringliteral">&quot;     vtx x,y &quot;</span> &lt;&lt; tmpx &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; tmpy &lt;&lt; std::endl;
<a name="l00155"></a>00155               }
<a name="l00156"></a>00156             }
<a name="l00157"></a>00157 
<a name="l00158"></a>00158             <span class="comment">// decide whether to copy polygon to new map. NB checks cell CENTER. for future cell layouts, might want to</span>
<a name="l00159"></a>00159             <span class="comment">// use all vertices, eg in case of cut-off edge polygons. see above vertex loop to quickly do this.</span>
<a name="l00160"></a>00160             <span class="keywordtype">bool</span> addPoly = <a class="code" href="classldmx_1_1EcalHexReadout.html#a68855d677a80acb01e8b82dc967cff8f">isInside</a>(x/(lengthWide_/2.), y/(lengthWide_/2.)); <span class="comment">// NB lengthWide, not gridWidth!</span>
<a name="l00161"></a>00161 
<a name="l00162"></a>00162             <span class="keywordflow">if</span>(addPoly){
<a name="l00163"></a>00163                 <span class="keywordflow">if</span>(verbose_&gt;1) std::cout &lt;&lt; TString::Format(<span class="stringliteral">&quot;[buildCellMap] Copying poly with ID %d and (x,y) (%.2f,%.2f)&quot;</span>, <span class="keywordtype">id</span>, x, y) &lt;&lt; std::endl;
<a name="l00164"></a>00164                 <span class="keywordtype">bool</span> isCopied = (std::find(std::begin(cellIdCopied), std::end(cellIdCopied), <span class="keywordtype">id</span>) != cellIdCopied.end());
<a name="l00165"></a>00165                 <span class="keywordflow">if</span>(verbose_&gt;1 &amp;&amp; isCopied) std::cout &lt;&lt; <span class="stringliteral">&quot;    cell was used already! not copying.&quot;</span> &lt;&lt; std::endl;
<a name="l00166"></a>00166                 <span class="keywordflow">if</span>(!isCopied){
<a name="l00167"></a>00167                     <a class="code" href="classldmx_1_1EcalHexReadout.html#affdf0e47ee886fb03aac6fbd6af6b641">ecalMap_</a>-&gt;AddBin(poly);
<a name="l00168"></a>00168                     cellPositionMap_[ecalMapID] = std::pair&lt;double,double&gt;(x,y);
<a name="l00169"></a>00169                     ecalMapID++;
<a name="l00170"></a>00170                     cellIdCopied.push_back(<span class="keywordtype">id</span>);
<a name="l00171"></a>00171                 }
<a name="l00172"></a>00172             }
<a name="l00173"></a>00173         }
<a name="l00174"></a>00174 
<a name="l00175"></a>00175         <span class="keywordflow">if</span>(verbose_&gt;0) std::cout &lt;&lt; std::endl;
<a name="l00176"></a>00176         <span class="keywordflow">return</span>;
<a name="l00177"></a>00177     }
<a name="l00178"></a>00178 
<a name="l00179"></a>00179 
<a name="l00180"></a><a class="code" href="classldmx_1_1EcalHexReadout.html#ac4aeb2b9831ad98110e4984f2c6f766b">00180</a>     <span class="keywordtype">void</span> <a class="code" href="classldmx_1_1EcalHexReadout.html#ac4aeb2b9831ad98110e4984f2c6f766b">EcalHexReadout::buildNeighborMaps</a>(){
<a name="l00191"></a>00191         <span class="keywordflow">if</span>(verbose_&gt;0) std::cout &lt;&lt; std::endl &lt;&lt; TString::Format(<span class="stringliteral">&quot;[buildNeighborMap] Building with %d cells wide&quot;</span>, nCellsWide_) &lt;&lt; std::endl;
<a name="l00192"></a>00192 
<a name="l00193"></a>00193         NNMap_.clear();
<a name="l00194"></a>00194         NNNMap_.clear();
<a name="l00195"></a>00195         <span class="keywordflow">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span>&amp; centerChannel : cellModulePositionMap_) {
<a name="l00196"></a>00196             <span class="keywordtype">int</span> centerID = centerChannel.first;
<a name="l00197"></a>00197             <span class="keywordtype">double</span> centerX = centerChannel.second.first;
<a name="l00198"></a>00198             <span class="keywordtype">double</span> centerY = centerChannel.second.second;
<a name="l00199"></a>00199             <span class="keywordflow">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span>&amp; probeChannel : cellModulePositionMap_) {
<a name="l00200"></a>00200                 <span class="keywordtype">int</span> probeID = probeChannel.first;
<a name="l00201"></a>00201                 <span class="keywordtype">double</span> probeX = probeChannel.second.first;
<a name="l00202"></a>00202                 <span class="keywordtype">double</span> probeY = probeChannel.second.second;
<a name="l00203"></a>00203                 <span class="keywordtype">double</span> dist = sqrt( (probeX-centerX)*(probeX-centerX) + (probeY-centerY)*(probeY-centerY) );
<a name="l00204"></a>00204                 <span class="keywordflow">if</span>(      dist &gt; 1*cellr_  &amp;&amp; dist &lt;= 3.*cellr_)  { NNMap_[centerID].push_back(probeID); }
<a name="l00205"></a>00205                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>( dist &gt; 3.*cellr_ &amp;&amp; dist &lt;= 4.5*cellr_) {NNNMap_[centerID].push_back(probeID); }
<a name="l00206"></a>00206             }
<a name="l00207"></a>00207             <span class="keywordflow">if</span>(verbose_&gt;1) std::cout &lt;&lt; TString::Format(<span class="stringliteral">&quot;Found %d NN and %d NNN for cellModuleID %d with x,y (%.2f,%.2f)&quot;</span>,
<a name="l00208"></a>00208                                                         NNMap_[centerID].size(), NNNMap_[centerID].size(), centerID, centerX, centerY) &lt;&lt; std::endl;
<a name="l00209"></a>00209         }
<a name="l00210"></a>00210         <span class="keywordflow">if</span>(verbose_&gt;2){
<a name="l00211"></a>00211             <span class="keywordtype">double</span> specialX = 0.5*moduleR_ - 0.5*cellr_; <span class="comment">// center of cell which is upper-right corner of center module</span>
<a name="l00212"></a>00212             <span class="keywordtype">double</span> specialY = moduler_ - 0.5*cellR_;
<a name="l00213"></a>00213             <span class="keywordtype">int</span> specialCellModuleID = <a class="code" href="classldmx_1_1EcalHexReadout.html#add519442377223789025ea1d7a02d4ec">getCellModuleID</a>(specialX,specialY);
<a name="l00214"></a>00214             std::cout &lt;&lt; <span class="stringliteral">&quot;The neighbors of the bin in the upper-right corner of the center module, with cellModuleID &quot;</span> 
<a name="l00215"></a>00215                       &lt;&lt; specialCellModuleID &lt;&lt; <span class="stringliteral">&quot; include &quot;</span> &lt;&lt; std::endl;
<a name="l00216"></a>00216             <span class="keywordflow">for</span>(<span class="keyword">auto</span> centerNN : NNMap_.at(specialCellModuleID)){
<a name="l00217"></a>00217                 std::cout &lt;&lt; TString::Format(<span class="stringliteral">&quot; NN ID %d (x,y) (%.2f, %.2f)&quot;</span>,
<a name="l00218"></a>00218                              centerNN,<a class="code" href="classldmx_1_1EcalHexReadout.html#a065a5d0288f1ef3fc64c542e6dfe492f">getCellCenterAbsolute</a>(centerNN).first,<a class="code" href="classldmx_1_1EcalHexReadout.html#a065a5d0288f1ef3fc64c542e6dfe492f">getCellCenterAbsolute</a>(centerNN).second) &lt;&lt; std::endl;
<a name="l00219"></a>00219             }
<a name="l00220"></a>00220             <span class="keywordflow">for</span>(<span class="keyword">auto</span> centerNNN : NNNMap_.at(specialCellModuleID)){
<a name="l00221"></a>00221                 std::cout &lt;&lt; TString::Format(<span class="stringliteral">&quot; NNN ID %d (x,y) (%.2f, %.2f)&quot;</span>,
<a name="l00222"></a>00222                              centerNNN,<a class="code" href="classldmx_1_1EcalHexReadout.html#a065a5d0288f1ef3fc64c542e6dfe492f">getCellCenterAbsolute</a>(centerNNN).first,<a class="code" href="classldmx_1_1EcalHexReadout.html#a065a5d0288f1ef3fc64c542e6dfe492f">getCellCenterAbsolute</a>(centerNNN).second) &lt;&lt; std::endl;
<a name="l00223"></a>00223             }
<a name="l00224"></a>00224             std::cout &lt;&lt; TString::Format(<span class="stringliteral">&quot;This bin is a distance of %.2f away from a module edge. Decision isEdge %d.&quot;</span>,
<a name="l00225"></a>00225                          <a class="code" href="classldmx_1_1EcalHexReadout.html#a42f58771ffbab6bec6f5983c310105ed">distanceToEdge</a>(specialCellModuleID),isEdgeCell(specialCellModuleID)) &lt;&lt; std::endl;
<a name="l00226"></a>00226         }
<a name="l00227"></a>00227         <span class="keywordflow">if</span>(verbose_&gt;0) std::cout &lt;&lt; std::endl;
<a name="l00228"></a>00228         <span class="keywordflow">return</span>;
<a name="l00229"></a>00229     }
<a name="l00230"></a>00230 
<a name="l00231"></a><a class="code" href="classldmx_1_1EcalHexReadout.html#a42f58771ffbab6bec6f5983c310105ed">00231</a>     <span class="keywordtype">double</span> <a class="code" href="classldmx_1_1EcalHexReadout.html#a42f58771ffbab6bec6f5983c310105ed">EcalHexReadout::distanceToEdge</a>(<span class="keywordtype">int</span> cellModuleID)<span class="keyword"> const </span>{
<a name="l00232"></a>00232         <span class="comment">// https://math.stackexchange.com/questions/1210572/find-the-distance-to-the-edge-of-a-hexagon</span>
<a name="l00233"></a>00233         <span class="keywordtype">int</span> cellID = <a class="code" href="classldmx_1_1EcalHexReadout.html#a9c8a3cde93d9d68fbec7321174da73e8">separateID</a>(cellModuleID).first;
<a name="l00234"></a>00234         XYCoords cellLocation = <a class="code" href="classldmx_1_1EcalHexReadout.html#afd2fc0a835408ddb22d7587edc184574">getCellCenterRelative</a>(cellID);
<a name="l00235"></a>00235         <span class="keywordtype">double</span> x = fabs(cellLocation.first); <span class="comment">// bring to first quadrant</span>
<a name="l00236"></a>00236         <span class="keywordtype">double</span> y = fabs(cellLocation.second);
<a name="l00237"></a>00237         <span class="keywordtype">double</span> r = sqrt(x*x+y*y);
<a name="l00238"></a>00238         <span class="keywordtype">double</span> theta = (r &gt; 1E-3) ? fabs(std::atan(y/x)) : 0;
<a name="l00239"></a>00239         <span class="keywordflow">if</span>(x &lt; moduleR_/2.) <span class="keywordflow">return</span> (moduler_ - y); <span class="comment">// closest line is straight vertical to top edge</span>
<a name="l00240"></a>00240         <span class="keywordtype">double</span> dist = sqrt(3.)*moduleR_/(std::sin(theta) + sqrt(3.)*std::cos(theta));
<a name="l00241"></a>00241         <span class="keywordflow">return</span> dist;
<a name="l00242"></a>00242     }
<a name="l00243"></a>00243 
<a name="l00244"></a><a class="code" href="classldmx_1_1EcalHexReadout.html#a68855d677a80acb01e8b82dc967cff8f">00244</a>     <span class="keywordtype">bool</span> <a class="code" href="classldmx_1_1EcalHexReadout.html#a68855d677a80acb01e8b82dc967cff8f">EcalHexReadout::isInside</a>(<span class="keywordtype">double</span> normX, <span class="keywordtype">double</span> normY)<span class="keyword"> const </span>{
<a name="l00245"></a>00245         <span class="keywordflow">if</span>(verbose_&gt;2) std::cout &lt;&lt; TString::Format(<span class="stringliteral">&quot;[isInside] Checking if normXY=(%.2f,%.2f) is inside.&quot;</span>,normX,normY) &lt;&lt; std::endl;
<a name="l00246"></a>00246         normX = fabs(normX), normY = fabs(normY);
<a name="l00247"></a>00247         <span class="keywordtype">double</span> xvec = -1,  yvec = -1./sqrt(3);
<a name="l00248"></a>00248         <span class="keywordtype">double</span> xref = 0.5, yref = sqrt(3)/2.;
<a name="l00249"></a>00249         <span class="keywordflow">if</span>( (normX &gt; 1.) || (normY &gt; yref) ){
<a name="l00250"></a>00250             <span class="keywordflow">if</span>(verbose_&gt;2) std::cout &lt;&lt; <span class="stringliteral">&quot;[isInside]   they are outside quadrant.&quot;</span> &lt;&lt; std::endl;
<a name="l00251"></a>00251             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00252"></a>00252         }
<a name="l00253"></a>00253         <span class="keywordtype">double</span> dotProd = (xvec*(normX-xref) + yvec*(normY-yref));
<a name="l00254"></a>00254         <span class="keywordflow">if</span>(verbose_&gt;2) std::cout &lt;&lt; TString::Format(<span class="stringliteral">&quot;[isInside] they are inside quadrant. Dot product (&gt;0 is inside): %.2f &quot;</span>, dotProd) &lt;&lt; std::endl;
<a name="l00255"></a>00255         <span class="keywordflow">return</span> (dotProd &gt; 0.);
<a name="l00256"></a>00256     }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
